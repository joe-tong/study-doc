# 算法篇-初识算法

**作者：星晴（当地小有名气，小到只有自己知道的杰伦粉）**

## 1. 为什么算法如此重要？

​      我们先不给算法是否重要就轻易下了一个结论，并且我也先不着急给算法下定义做解释。

 我们现在先来看看一种现象: 哪种语言是开发者们可以一直高高兴兴用来编程的？一位美国的开发者通过Twitter对开发者们进行了一项调查 ：你是否喜爱XX语言 调查结果分析图:

![](https://images.cnblogs.com/cnblogs_com/chenkai/WindowsLiveWriter/f66d441c7131_C15D/200904141721242268511421_5ce82cde-1b7d-4101-8367-d77dad64bfe7.jpg)

​        基本上每个月都会有一些相关对语言使用程度做了一个排名. 大家业见怪不怪了,也许你会好几种语言, 但随着工作时间增加和对技术深入研究你会发现: **不是具体的技术而是算法这些基本的东西成为了技术深入的软肋, 特别是在紧要关口 这个软肋往往就会更疼**。

​        现在很多算法已经被包装到了语言、工具或者框架中， 人都是懒惰 ，既然有现成的东西不用 为何要费力去创新。 这也就导致长期适用单一编程开发者视野上狭隘， 开发者很难有属于自己的思维方式. 这就是为什么有些人说自己做到一定程度后成了熟练“代码工人”也不难解，起码这个问题让我感到很悲哀。

​       **Ruby之父松本行弘[日本同行]就曾表示，注重的是算法而不是工具**, 如果没有自己的思维方式和编程逻辑，很容易对某种具体的技术或者工具产生依赖性, 而这些编程工具和技术往往是国外开发， 假设有一天我们没有这些现成的工具和技术 我们该怎么办? 岂不是成了一穷二白了吗？但是如果有了稳固的算法思维编程世界里东西都不可怕。

​        今天出了JAVA 明天出了一个C#， 后天还不知道要出了一个什么XXX语言和新技术，于是乎你也成了那赶潮大军中一员 一路疲惫被人牵着鼻子走, 到头来你发现越深入步伐走得越慢越是吃力，往往技术了解得越多、做得东西越深，这样的体会越明显， 借用一位网友的话说就是"内功”不到位. C# java Ruby 只是两个你用来练习武功的招式, “内功”则是这些花哨武功招式后本质, 招式可以很多种，如果没有 ”内功” 招式变换再多也只是表面文章 罢了， 注定你是成不了一个名副其实的”武林高手”。

​        看完了这个现象后，在回头来说算法定义，**算法说白了就是是解决问题的步骤**，可以把算法定义成解决一个分类问题的任意一种特殊的方法。

**编程世界中    算法  +  数据结构  = 程序**

**总结一句：学好算法，走遍编程世界都不怕**

## 2. 算法的性能标准-空间、时间复杂度

### 2.1 时间复杂度

​        为了方便表达算法的时间复杂度，计算机科学家从数学界借鉴了一种简洁又通用的方式，那就是大O记法。这种规范化语言使得我们可以轻松地指出一个算法的性能级别，也令学术交流变得简单。

​       掌握了大O记法，就掌握了算法分析的专业工具。

**大O记法：**不关注算法所用的时间，只关注其所用的**步数**。

**推导算法：大O推导法**

```
1、用常数1取代运行时间中的所有加法常数
2、在修改后的运行次数函数中，只保留最高阶项 
3、如果最高阶项存在且不是1，那么我们就去除于这个项相乘的常数。
```

**常见的大O表达式：**

- **O(1): 常数阶**

  ```java
  void func(){
      int i=0;//执行1次
      i++;//执行1次
      i++;//执行1次
      i++;//执行1次
  }
  //共执行了4次，所以时间复杂度为O(4);根据大O推导法，略去常数，所以此函数的时间复杂度为O(1);
  ```

- **O(n): 线性阶**

  ````java
  void main(){
     for(int i=0;i<n;i++)
      {
          func();
      }
  }
  void func(){
     printf("大O推导法");//执行1次
  }
  //在main中，func共被执行了n次，所以main的时间复杂度为O(n);
  ````

- **O(logn): 对数阶**

  ```java
  void main(){
     for(int i=1;i<n;i++)
      {
          func();
          i=2i;
      }
  }
  void func(){
     printf("大O推导法");//执行1次
  }
  /*
  在main中，
  因为i每次被乘2，所以，执行的算法为 2的几次相乘 大于 n，即 2^x>n,--> x= log2n  ,  在推导对数时间复杂度时，一般都是以10作为对数的底数。 func共被执行了logn次，所以main的时间复杂度为O(logn);
  */
  ```

- **O(n^2): 平方阶**

  ```java
  void main(){
     for(int i=1;i<n;i++)
      {
         for(int j=1;j<n;j++)
          {
              func();
          }
      }
  }
  void func(){
     printf("大O推导法");//执行1次
  }
  /*
  在main中， func()共被执行了n^2,所以main的时间复杂度为O(n^2);
  */
  ```

  **时间复杂度所耗费的时间是：**
  O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) <O(2n) < O(n!) <O(nn)

### 2.2 空间复杂度

​      空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。

```
   既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。
空间复杂度分析和时间复杂度分析类似，你只需要把 **一次执行次数**等于**一个单位内存**把大 O 复杂度表示法重推一遍就会啦~
```

**常见的大O表达式：**

- **O(1): 常数阶**

  ​        如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)

  ```java
  int i = 1;
  int j = 2;
  ++i;
  j++;
  int m = i + j;
  
  //代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)
  ```

- **O(n): 线性阶**

  ```java
  int[] m = new int[n]
  for(i=1; i<=n; ++i)
  {
     j = i;
     j++;
  }
  /**这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)
  */
  ```

## 3. 总结

学会**大O记法**，我们在比较算法时就有了一致的参考系。有了它，我们就可以在现实场景中测量各种数据结构和算法，写出更快的代码，更轻松地应对高负荷的环境。