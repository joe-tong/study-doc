# 面试题-微服务章节

## 1.微服务架构

![copy.png](https://ae04.alicdn.com/kf/U2b0ce27b24bc440e8500fb00aeac3129o.jpg)

## 2.缓存和异步消息

### 2.1 Redis

#### 2.1.1 缓存数据类型

- 字符串

  ```
  1.二进制安全的，意味着该类型可以接受任何格式的数据
  2.最大512M的值
  3.由于不能高效的计算字符串长短和追加操作；redis处理c语言字符串之外，还需要处理redis的服务协议等待，使用了SDS（简单动态字符串），是二进制安全的
  struct sdsstr {
      //buf 已占用长度
      int len；
      
      //buf 剩余可用长度
      int free；
     
      //实际保存字符串数据的地方
      char buf[];
      
  }
  
  4.二进制安全就是输入任何字节都能正确处理, 即使包含零值字节.
  ```

- hash

- set

- list

- sortedSet

#### 2.1.2 Redis线程模型（单线程、NIO、异步事件处理）

```
redis这么快的核心原因

1.存储在内存，操作都是内存级别
```

#### 2.1.3 redis集群

```
1.redis集群之间如何同步数据的？
RDB、AOF
```

#### 2.1.4 分布式锁

### 2.2 异步消息（active mq、rabbitmq、rocketmq、kafka）

#### 2.2.1 优势

- 解耦
- 异步
- 消峰

#### 2.2.1 缺点

- 消息丢失

  ```
  原因：网络丢失
  
  解决：生产者发送消息给Broker端，Broker端给producer返回一个ack
  
  原因：提前消费（未处理异常）
  解决: 消费者正确使用完这个消息，在ack
  
  原因：主从切换
  解决：Broker端给producer返回一个ack.all(所有节点全部同步)
  ```

- 重复消费

  ```
  幂等性
  
  1.reids的原子性操作
  2.数据库的主键或者unique
  ```

- 消息堆积（高并发）

  ```
  原因：
  1.生产者消息增加
  2.消费者消费变慢
  
  3.多建立几个分区，然后把原来的消费者转发到新分区，让原来的分区组消费
  ```

- 顺序消费



## 3.分布式锁

### 3.1 基于redis

```
基本原来：setNx 获取到锁返回1，失败返回0

场景一：
setNx
//逻辑
deletelock

场景二：
如果逻辑没有执行完了，这个时候服务中断了，没有删除锁，那这把锁一直有效

1.加一个超时时间，超时时间不能setNx分开使用，jedis有这个api

场景三：
1.超时时间怎么确定呢？
超时时太短：
逻辑业务超时了，锁自动释放了，加锁就没有用了；
超时时间太长：黄花菜都没有了

redision.getLock(Key);
lock.lock();

只要redis的锁住的程序没有执行完，轮询，加过期expire，
其他锁抢占，会自旋

场景四：
如果redis主从，锁没有同步到从节点，主节点挂了，锁又丢失了

zookeeper 能保证数据的一致性

```



### 3.2 基于Zookeeper

## 4.分布式事务

## 5.分布式Session