# Java数据结构篇

![1597113579054](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1597113579054.png)

## 1.Collection

### 1.1 List

#### 1.1.1 ArrayList

#### 1.1.2 LinkedList

#### 1.1.3 Vector

### 1.2 Set

#### 1.2.1 HashSet

#### 1.2.2 TreeSet

#### 1.2.3 LinkedHashSet

### 1.3 Queue

## 2.Map

#### 2.1 HashMap

```
1.哈希表
2.数组长度16
3.链表长度大于8，jdk8会转成红黑树
```

```
问题：拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？

答案：之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。
    而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
```

```
问题：jdk8中对HashMap做了哪些改变？

答案：
1、在java 1.8中，如果链表的长度超过了8，那么链表将转换为红黑树。（桶的数量必须大于64，小于64的时候只会扩容）
2、发生hash碰撞时，java 1.7 会在链表的头部插入，而java 1.8会在链表的尾部插入
3、在java 1.8中，Entry被Node替代(换了一个马甲)
```

```
问题：HashMap如何解决哈希碰撞？

答案：采用链地址法：就是将每个元素看出单链表中的节点，都有指向下一个节点的指针。这是一个不错的方法，能够减少重哈希的概率。
```

```
问题：java 1.7 会在链表的头部插入，而java 1.8会在链表的尾部插入？

答案：因为头插法会造成死链
```

```
问题：为什么HashMap的数据长度是16？

```



#### 2.2 TreeMap

#### 2.3 HashTable

#### 2.4 ConcurrentHashMap