# JVM

![1597045286506.png](https://ae04.alicdn.com/kf/U67e871594b9f4b4c9ff5f3670e053a66I.jpg)

## 1.Java代码的执行

省略。。。

## 2.内存管理

### 2.1内存空间

![1597046152230.png](https://ae03.alicdn.com/kf/U824f851969ef4d81a3cc21e75efa733fC.jpg)

![1597046308784.png](https://ae03.alicdn.com/kf/U05aeccc7d02a47498508aaf8f0497328V.jpg)

线程共享数据区域

- 方法区：运行时常量池

  ```
    存储JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
  ```

- 堆：创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 

  垃圾收集的最重要的内存区域

线程私有数据区域

- 虚拟机栈：描述java方法执行的内存模型

  ```
     每个方法在执行的同时都会创建一个栈帧（Stack Frame）
  用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成
  的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
  ```

- 本地方法栈：本地方法区和 Java Stack 作用类似

  ```
  区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为 Native 方法服务
  ```

- 程序计数器：当前线程所执行的字节码的行号指示器

  ```
  这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域
  ```

### 2.2 内存分配

#### 2.2.1 堆上分配

```
    Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代
```

##### 2.2.1.1 新生代

​        是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 

MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。 

```
1.eden
2.servivorFrom
3.servivorTo
```

​        MinorGC 的过程（复制->清空->互换）,MinorGC 采用复制算法。

##### 2.2.1.2 老年代 

主要存放应用程序中生命周期长的内存对象。 

触发条件：

- 新生代的对象晋身入老年代，导致空间不够用时才触发。

- 当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间.

MajorGC 采用标记清除算法

#### 2.2.2 栈上分配

#### 2.2.3 TLAB分配



## 2.3 内存回收

![1597048948322.png](https://ae01.alicdn.com/kf/U7e02953dcf244d6481c01bcad7179c18o.jpg)

### 2.3.1 如何确定是垃圾

#### 2.3.1.1引用计数法

```
   个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。
```

#### 2.3.1.2可达性分享发

```
   为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。
```

​       要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过**两次标记过程**。两次标记后仍然是可回收对象，则将面临回收。

### 2.3.2 垃圾收集算法

#### 2.3.2.1 标记清除算法(Full GC)

```
操作：标注和清除
问题：内存碎片化严重，
```

#### 2.3.2.2 复制算法（Minor GC）

```
操作：按内存分为等大的两块。每次只使用其中一块，当这一块满后将尚存活的对象复制到另一块上去，把已使用的内存清掉
优点：解决了复制算法的内存碎片化问题
```

#### 2.3.2.3标记整理算法

```
操作：结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象
```

#### 2.3.2.4**分代收集算法** 

```
就是根据对象的生命周期新生代和老年代执行收集算法
新生代：复制算法
老年代：标记整理算法
```

#### 2.3.2.5 Java四种引用类型

```
强引用:

在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即 使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之 一。 

软引用:

软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 

弱引用:

弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。 

虚引用:

虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚 引用的主要作用是跟踪对象被垃圾回收的状态
```

### 2.3.3 **GC** 垃圾收集器

![1597051717611.png](https://ae03.alicdn.com/kf/U0f3583194e6844f5913955c168a0c97e1.jpg)

#### 2.3.3.1 Serial **垃圾收集器（单线程、复制算法）**

#### 2.3.3.2 ParNew 垃圾收集器（Serial+多线程）

#### 2.3.3.3  Parallel Scavenge 收集器（多线程复制算法、高效）

#### 2.3.3.4 Serial Old 收集器（单线程标记整理算法 ）

#### 2.3.3.5 Parallel Old收集器（多线程标记整理算法）

#### 2.3.3.6 CMS 收集器（多线程标记清除算法）

#### 2.3.3.7 G1收集器 

```
Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收
集器两个最突出的改进是：
1. 基于标记-整理算法，不产生内存碎片。
2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
```

## 3.**JVM** 类加载机制

JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这 

五个过程。

![1597052496205.png](https://ae02.alicdn.com/kf/Ub3652c89e80745f69b749ce77177c8d7W.jpg)

### 3.1 类加载过程

#### 3.1.1 加载

​      这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对 

象，作为方法区这个类的各种数据的入口

#### 3.1.2 验证

​      确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求

#### 3.1.3  准备

​     在方法区中分配这些变量所使用的内存空间

#### 3.1.4 解析

​     虚拟机将常量池中的符号引用替换为直接引用的过程

#### 3.1.5 初始化

​     初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载 器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 

### 3.2 类加载器

####  3.2.1 启动类加载器

负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。 

#### 3.2.2 扩展类加载器

负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类 库。 

#### 3.2.3 应用程序类加载器

负责加载用户路径（classpath）上的类库。 

JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。

![1597112596908.png](https://ae04.alicdn.com/kf/Uf005afd144cd4957b5bc3033a4406981s.jpg)

### 3.3 **双亲委派** 

​         当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父 类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中， 只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的 Class），子类加载器才会尝试自己去加载。 

