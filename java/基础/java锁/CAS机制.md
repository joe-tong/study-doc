# (白话理解)CAS机制

### 通过一段对话我们来了解cas用意



![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142408987-2093651899.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142428753-1669180149.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142430471-225351748.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142500096-1427562048.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142504799-421806684.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142506378-423385790.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142508549-793117636.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142509471-1716933155.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142510237-1236016542.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142511799-1346955733.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142515503-551725483.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142522659-2136566690.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142524518-461076297.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142526003-26452533.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142527378-1040467173.png)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142528424-1010518323.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142529409-966955979.jpg)

示例程序：启动两个线程，每个线程中让静态变量count循环累加100次。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142530440-2089624774.jpg)

最终输出的count结果是什么呢？一定会是200吗？

加了同步锁之后，count自增的操作变成了原子性操作，所以最终的输出一定是**count=200**，代码实现了线程安全。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142531581-25052835.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142532893-620508865.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142534190-1369968744.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142535159-470469724.jpg)

所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如**AtomicBoolean**，**AtomicInteger**，**AtomicLong**。它们分别用于Boolean，Integer，Long类型的原子性操作。

 

现在我们尝试在代码中引入AtomicInteger类：

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142536128-2024231359.png)

为什么这么说呢？关键在于**性能**问题。

 

Synchronized关键字会让没有得到锁资源的线程进入**BLOCKED**状态，而后在争夺到锁资源后恢复为**RUNNABLE**状态，这个过程中涉及到操作系统**用户模式**和**内核模式**的转换，代价比较高。

 

尽管Java1.6为Synchronized做了优化，增加了从**偏向锁**到**轻量级锁**再到**重量级锁**的过度，但是在最终转变为重量级锁之后，性能仍然较低。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142536878-372118513.jpg)

**什么是CAS？**

 

CAS是英文单词**Compare And Swap**的缩写，翻译过来就是比较并替换。

 

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

 

更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。

 

这样说或许有些抽象，我们来看一个例子：

 

 

1.在内存地址V当中，存储着值为10的变量。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142540362-571280295.png)

2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142542299-1617994496.png)

3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142543784-1625100143.png)

4.线程1开始提交更新，首先进行**A和地址V的实际值比较（Compare）**，发现A不等于V的实际值，提交失败。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142545221-837543615.png)

5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为**自旋**。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142546909-270453852.png)

6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行**Compare**，发现A和地址V的实际值是相等的。

 

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142548299-328053032.png)

7.线程1进行**SWAP**，把地址V的值替换为B，也就是12。

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142625753-443716413.png)

从思想上来说，Synchronized属于**悲观锁**，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于**乐观锁**，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。

 

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142557487-1048385838.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142559268-1039292216.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142600737-1339558436.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142602268-690462947.jpg)

 

 

 ![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142640096-1060113561.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142646284-572586103.jpg)

![img](https://images2017.cnblogs.com/blog/1193919/201801/1193919-20180102142648034-1818658423.jpg)

**CAS的缺点：**

 

**1.CPU开销较大**

在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。

 

 

**2.不能保证代码块的原子性**

CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。

 

 

**3.ABA问题**

这是CAS机制最大的问题所在。

https://www.jianshu.com/p/8b227a8adbc1